<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Runloop | Coolnaut space</title><meta name="author" content="Coolnaut"><meta name="copyright" content="Coolnaut"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 引子Runloop是iOS开发的一个老生常谈的话题，网上的资料也是很多，但是我想了解的关键地方总是一笔带过，因此自己看源码，进行了资料补充，从头开始。  不再想以教程的方式来写总结了，真正的教程在各大知名网站上均有，日后博文将抽丝剥茧，关键的地方进行雕琢。  2. RunLoop为什么需要RunLoop。 12345678910void func1() &amp;#123;  &amp;#125;void">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop">
<meta property="og:url" content="http://www.baidu.com/2021/03/19/Runloop/index.html">
<meta property="og:site_name" content="Coolnaut space">
<meta property="og:description" content="1. 引子Runloop是iOS开发的一个老生常谈的话题，网上的资料也是很多，但是我想了解的关键地方总是一笔带过，因此自己看源码，进行了资料补充，从头开始。  不再想以教程的方式来写总结了，真正的教程在各大知名网站上均有，日后博文将抽丝剥茧，关键的地方进行雕琢。  2. RunLoop为什么需要RunLoop。 12345678910void func1() &amp;#123;  &amp;#125;void">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg">
<meta property="article:published_time" content="2021-03-19T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-19T16:00:00.000Z">
<meta property="article:author" content="Coolnaut">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg"><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/43647498?s=40&v=4"><link rel="canonical" href="http://www.baidu.com/2021/03/19/Runloop/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Coolnaut","link":"链接: ","source":"来源: Coolnaut space","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Runloop',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-20 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3849542_d3roptmaros.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.niupic.com/images/2023/01/06/aeXJ.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-labels"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-bxs-category"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-about"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Coolnaut space</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-labels"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-bxs-category"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-about"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Runloop</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-19T16:00:00.000Z" title="发表于 2021-03-20 00:00:00">2021-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-19T16:00:00.000Z" title="更新于 2021-03-20 00:00:00">2021-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Runloop"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h1><p>Runloop是iOS开发的一个老生常谈的话题，网上的资料也是很多，但是我想了解的关键地方总是一笔带过，因此自己看源码，进行了资料补充，从头开始。</p>
<blockquote>
<p>不再想以教程的方式来写总结了，真正的教程在各大知名网站上均有，日后博文将抽丝剥茧，关键的地方进行雕琢。</p>
</blockquote>
<h1 id="2-RunLoop"><a href="#2-RunLoop" class="headerlink" title="2. RunLoop"></a>2. RunLoop</h1><p>为什么需要RunLoop。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">   func1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   func();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序，在线程执行完main函数后，就结束了，什么也没了。但是手机APP不行，手机APP需要保活，在任何时候需要响应用户的操作以及系统的事件。让程序不结束的方案就是循环。此时Loop就出现了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure>

<p>另外一个问题就是：不能一直空循环，因为空循环是对CPU的浪费。</p>
<p>走进源码了解RunLoop，NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。我们可看CFRunLoop源码，这里不介绍整个CFRunLoop.h，CFRunLoop.c的源码，主要是关键的部分。</p>
<p>RunLoop不仅仅需要了解loop的部分，还需要有基础的铺垫，先将一些必须了解的数据结构先认识一下。</p>
<h1 id="3-RunLoopSource"><a href="#3-RunLoopSource" class="headerlink" title="3. RunLoopSource"></a>3. RunLoopSource</h1><p>事件源，它是唤醒线程和线程任务关键之一，事件源有两种，一个是输入事件源，一个是定时器事件源。首先看看输入事件源。</p>
<blockquote>
<p>线程在一个loop执行完后，若没有其他任务。将会进入休眠，此时需要其他事件源进行唤醒</p>
</blockquote>
<h2 id="3-1-CFRunLoopSource"><a href="#3-1-CFRunLoopSource" class="headerlink" title="3.1 __CFRunLoopSource"></a>3.1 __CFRunLoopSource</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;        <span class="comment">// core foundation&quot;对象&quot;都是以这个开始</span></span><br><span class="line">    <span class="type">uint32_t</span> _bits;  			      <span class="comment">//  基本保留位的位 1 用于信号状态</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFIndex _order;			        <span class="comment">// 通用的顺序索引 </span></span><br><span class="line">    CFMutableBagRef _runLoops;	<span class="comment">// ref ---&gt; 指向当前的loop</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>	                    <span class="comment">// 联合体类型的context版本</span></span><br><span class="line">				CFRunLoopSourceContext version0;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        CFRunLoopSourceContext1 version1;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-CFRuntimeBase"><a href="#3-2-CFRuntimeBase" class="headerlink" title="3.2 __CFRuntimeBase"></a>3.2 __CFRuntimeBase</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRuntimeBase</span> &#123;</span></span><br><span class="line">    <span class="type">uintptr_t</span> _cfisa;   <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">uint8_t</span> _cfinfo[<span class="number">4</span>]; <span class="comment">// 表示 run loop 状态如：Sleeping/Deallocating 等等很多信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> _rc;       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; CFRuntimeBase;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFBoolean</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFString</span> &#123;</span></span><br><span class="line">    CFRuntimeBase base;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>    <span class="comment">// In many cases the allocated structs are smaller than these</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">inline1</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 会发现其实每个结构体中都会有 __CFRuntimeBase 对象</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-CFRunLoopSourceContext"><a href="#3-3-CFRunLoopSourceContext" class="headerlink" title="3.3 CFRunLoopSourceContext"></a>3.3 CFRunLoopSourceContext</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 结构的版本号。必须为 0。</span></span><br><span class="line">    CFIndex version;</span><br><span class="line">  <span class="comment">// 指向程序定义数据的任意指针，可以在创建时与 CFRunLoopSource 关联。</span></span><br><span class="line">  <span class="comment">// 这个指针被传递给上下文中定义的所有回调。</span></span><br><span class="line">    <span class="type">void</span> *  info;</span><br><span class="line">  <span class="comment">// 程序定义info指针的保留回调。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *(*retain)(<span class="type">const</span> <span class="type">void</span> *info);</span><br><span class="line">  <span class="comment">// 程序定义info指针的释放回调。</span></span><br><span class="line">    <span class="type">void</span>    (*release)(<span class="type">const</span> <span class="type">void</span> *info);</span><br><span class="line">  <span class="comment">// 程序定义info指针的复制描述回调。</span></span><br><span class="line">    CFStringRef (*copyDescription)(<span class="type">const</span> <span class="type">void</span> *info);</span><br><span class="line">  <span class="comment">// 程序定义info指针的相等测试回调。</span></span><br><span class="line">    Boolean (*equal)(<span class="type">const</span> <span class="type">void</span> *info1, <span class="type">const</span> <span class="type">void</span> *info2);</span><br><span class="line">  <span class="comment">// 程序定义info指针的哈希计算回调。</span></span><br><span class="line">    CFHashCode  (*hash)(<span class="type">const</span> <span class="type">void</span> *info);</span><br><span class="line">    <span class="type">void</span>    (*schedule)(<span class="type">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">  <span class="comment">// 运行循环源的取消回调。 当源从运行循环模式中删除时，将调用此回调。</span></span><br><span class="line">    <span class="type">void</span>    (*cancel)(<span class="type">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">  <span class="comment">// 运行循环源的执行回调。当源触发时调用此回调。</span></span><br><span class="line">    <span class="type">void</span>    (*perform)(<span class="type">void</span> *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br></pre></td></tr></table></figure>

<p>在输入事件源<code>__CFRunLoopSource</code>的结构体中可以看到一个<code>version0</code>和一个<code>version1</code>。后面我们把<code>version0</code>版本的<code>source</code>称之为<code>source0</code>，反之为<code>source1</code>。<br><code>version0</code>：简单理解就是自定义的source，我们可以自己定义一个<code>source0</code>。按钮点击，手势等都已经被苹果帮我们定义好了(这个我们后面讨论一下)， Cocoa 还定义了一个自定义输入源，允许在任何线程上执行选择器(selector)。就是<code>performSelector</code>系列方法。这里不列举了。<br><code>version1</code>：这个是和内核相关了，基于<code>Mach por</code>t。其中需要到一个port，每个进程都有一个port，就是进程间通信需要用的。</p>
<p>说到这个就要说到一个点，就是我们知道屏幕触摸是硬件相关的，当我们点击屏幕时，此时并不知道是哪个APP的。因此呢这个时候内核先通过source1来这接收个硬件event，后面再分发到source0处理。因此如果追根溯源，点击时间终究还是source1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class="type">void</span> (*perform)(<span class="type">void</span> *), <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (perform) &#123;</span><br><span class="line">        perform(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">&quot;&quot;</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-CFRunLoopTimer"><a href="#4-CFRunLoopTimer" class="headerlink" title="4. __CFRunLoopTimer"></a>4. __CFRunLoopTimer</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仔细和__CFRunLoopSource对比就会发现有一些一样的成员</span></span><br><span class="line"><span class="comment">// 意义大多一样</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;					<span class="comment">//	 说过了</span></span><br><span class="line">    <span class="type">uint16_t</span> _bits;								<span class="comment">// 标志位</span></span><br><span class="line"><span class="comment">/* 基本保留位的位 0 用于触发状态 */</span></span><br><span class="line"><span class="comment">/* 基本保留位的第 1 位用于调用期间触发状态 */</span></span><br><span class="line"><span class="comment">/* 基本保留位的第 2 位用于唤醒状态 */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;					<span class="comment">// 记录下一次触发时间</span></span><br><span class="line">    CFTimeInterval _interval;							<span class="comment">//  理想时间间隔</span></span><br><span class="line">    CFTimeInterval _tolerance;          	<span class="comment">/* 执行的误差范围 */</span></span><br><span class="line">    <span class="type">uint64_t</span> _fireTSR;										<span class="comment">/* Terminate and stay resident，缩写为TSR */</span></span><br><span class="line">    CFIndex _order;												</span><br><span class="line">    <span class="comment">// 当 CFRunLoopTimer 对象触发时调用回调。</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout;			</span><br><span class="line">    <span class="comment">// 包含程序定义的数据和回调的结构，您可以使用它来配置 CFRunLoopTimer 的行为。</span></span><br><span class="line">    CFRunLoopTimerContext _context;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-CFRunLoopTimerCallBack"><a href="#4-1-CFRunLoopTimerCallBack" class="headerlink" title="4.1 CFRunLoopTimerCallBack"></a>4.1 CFRunLoopTimerCallBack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*CFRunLoopTimerCallBack)</span><span class="params">(CFRunLoopTimerRef timer, <span class="type">void</span> *info)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-CFRunLoopTimerContext"><a href="#4-2-CFRunLoopTimerContext" class="headerlink" title="4.2 CFRunLoopTimerContext"></a>4.2 CFRunLoopTimerContext</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex version;</span><br><span class="line">    void *  info;</span><br><span class="line">    const void *(*retain)(const void *info);</span><br><span class="line">    void    (*release)(const void *info);</span><br><span class="line">    CFStringRef (*copyDescription)(const void *info);</span><br><span class="line">&#125; CFRunLoopTimerContext;</span><br></pre></td></tr></table></figure>

<p>可以通过如下函数使用 <code>CFRunLoopTimerContext</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数符合 CFRunLoopTimerCallBack</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _runLoopTimerWithBlockContext(CFRunLoopTimerRef timer, <span class="type">void</span> *opaqueBlock) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(^<span class="type">timer_block_t</span>)</span> <span class="params">(CFRunLoopTimerRef timer)</span>;</span><br><span class="line">    <span class="type">timer_block_t</span> block = (<span class="type">timer_block_t</span>)opaqueBlock;</span><br><span class="line">    block(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopTimerRef <span class="title function_">CFRunLoopTimerCreateWithHandler</span><span class="params">(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (^block) (CFRunLoopTimerRef timer))</span> &#123;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopTimerContext blockContext;</span><br><span class="line">    blockContext.version = <span class="number">0</span>;</span><br><span class="line">    blockContext.info = (<span class="type">void</span> *)block;</span><br><span class="line">    blockContext.retain = (<span class="type">const</span> <span class="type">void</span> *(*)(<span class="type">const</span> <span class="type">void</span> *info))_Block_copy;</span><br><span class="line">    blockContext.release = (<span class="type">void</span> (*)(<span class="type">const</span> <span class="type">void</span> *info))_Block_release;</span><br><span class="line">    blockContext.copyDescription = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopTimerCreate(allocator, fireDate, interval, flags, order, _runLoopTimerWithBlockContext, &amp;blockContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可自行阅读如下函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopTimerRef <span class="title function_">CFRunLoopTimerCreate</span><span class="params">(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)</span> &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (isnan(interval)) &#123;</span><br><span class="line">        CRSetCrashLogMessage(<span class="string">&quot;NaN was used as an interval for a CFRunLoopTimer&quot;</span>);</span><br><span class="line">        HALT;</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopTimerRef memory;</span><br><span class="line">    UInt32 size;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __CFRunLoopTimer) - <span class="keyword">sizeof</span>(CFRuntimeBase);</span><br><span class="line">    memory = (CFRunLoopTimerRef)_CFRuntimeCreateInstance(allocator, CFRunLoopTimerGetTypeID(), size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == memory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSetValid(memory);</span><br><span class="line">    __CFRunLoopTimerUnsetFiring(memory);</span><br><span class="line">    __CFRunLoopLockInit(&amp;memory-&gt;_lock);</span><br><span class="line">    memory-&gt;_runLoop = <span class="literal">NULL</span>;</span><br><span class="line">    memory-&gt;_rlModes = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    memory-&gt;_order = order;</span><br><span class="line">    <span class="keyword">if</span> (interval &lt; <span class="number">0.0</span>) interval = <span class="number">0.0</span>;</span><br><span class="line">    memory-&gt;_interval = interval;</span><br><span class="line">    memory-&gt;_tolerance = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;</span><br><span class="line">    memory-&gt;_nextFireDate = fireDate;</span><br><span class="line">    memory-&gt;_fireTSR = <span class="number">0ULL</span>;</span><br><span class="line">    <span class="type">uint64_t</span> now2 = mach_absolute_time();</span><br><span class="line">    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    <span class="keyword">if</span> (fireDate &lt; now1) &#123;</span><br><span class="line">    memory-&gt;_fireTSR = now2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) &#123;</span><br><span class="line">    memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);</span><br><span class="line">    &#125;</span><br><span class="line">    memory-&gt;_callout = callout;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context-&gt;retain) &#123;</span><br><span class="line">        memory-&gt;_context.info = (<span class="type">void</span> *)context-&gt;retain(context-&gt;info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memory-&gt;_context.info = context-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line">    memory-&gt;_context.retain = context-&gt;retain;</span><br><span class="line">    memory-&gt;_context.release = context-&gt;release;</span><br><span class="line">    memory-&gt;_context.copyDescription = context-&gt;copyDescription;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memory-&gt;_context.info = <span class="number">0</span>;</span><br><span class="line">    memory-&gt;_context.retain = <span class="number">0</span>;</span><br><span class="line">    memory-&gt;_context.release = <span class="number">0</span>;</span><br><span class="line">    memory-&gt;_context.copyDescription = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timer 最后的回调会在这里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (func) &#123;</span><br><span class="line">        func(timer, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">&quot;&quot;</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	看到这里，其实会发现，真正的callBack其实就是 CFRunLoopTimerContext 中的 info</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="5-Runloop-Observer"><a href="#5-Runloop-Observer" class="headerlink" title="5. Runloop Observer"></a>5. Runloop Observer</h1><p>Observer 是非常重要的。观察下面的结构体，感觉像是的timer的结构体搬过来的，这样也可以猜到有一部分和timer是一样的，就是它的回调。其中_activities是observer独有的，代表观察的RunLoop的状态。如果RunLoop的状态为这个状态就会发起通知，调用回调。</p>
<h2 id="5-1-CFRunLoopObserver"><a href="#5-1-CFRunLoopObserver" class="headerlink" title="5.1 __CFRunLoopObserver"></a>5.1 __CFRunLoopObserver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> * <span class="title">CFRunLoopObserverRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;		<span class="comment">/* RunLoop的状态 */</span></span><br><span class="line">    CFIndex _order;			</span><br><span class="line">    CFRunLoopObserverCallBack _callout;	</span><br><span class="line">    CFRunLoopObserverContext _context;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-activities"><a href="#5-2-activities" class="headerlink" title="5.2 _activities"></a>5.2 _activities</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),         <span class="comment">//即将进入run loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),  <span class="comment">//即将处理timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">//即将处理source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),  <span class="comment">//被唤醒但是还没开始处理事件</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),          <span class="comment">//run loop已经退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>CF_OPTIONS</code>后，后面进行位与操作后，就可以直接得到状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取其中一段代码可以看到</span></span><br><span class="line"><span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br></pre></td></tr></table></figure>

<h2 id="5-3-callout"><a href="#5-3-callout" class="headerlink" title="5.3 _callout"></a>5.3 _callout</h2><p>在<code>__CFRunLoopDoObservers</code>方法中会调用下面的宏，通知事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line"><span class="comment">// 和timer的是一样的</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (func) &#123;</span><br><span class="line">        func(observer, activity, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">&quot;&quot;</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-应用"><a href="#5-4-应用" class="headerlink" title="5.4 应用"></a>5.4 应用</h2><h3 id="5-4-1-AutoreleasePool"><a href="#5-4-1-AutoreleasePool" class="headerlink" title="5.4.1 AutoreleasePool"></a>5.4.1 AutoreleasePool</h3><p>App 启动后，苹果在主线程 RunLoop 里注册了下面的 Observer：</p>
<ul>
<li>通知 Observers：<strong>即将进入 Loop</strong> &#x3D;&gt; 调用 _objc_autoreleasePoolPush() 创建自动释放池</li>
<li>do while<ul>
<li>…</li>
<li>通知 Observers：<strong>即将进入休眠</strong> &#x3D;&gt; 调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池</li>
<li>…</li>
</ul>
</li>
<li>通知 Observers: <strong>即将退出</strong> &#x3D;&gt; 调用 _objc_autoreleasePoolPop() 来释放自动释放池</li>
</ul>
<h3 id="5-4-2-事件响应"><a href="#5-4-2-事件响应" class="headerlink" title="5.4.2 事件响应"></a>5.4.2 事件响应</h3><p>苹果注册了一个 <strong>Source1</strong> 来接收触摸、加速、传感器等系统事件，随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<h3 id="5-4-3-手势识别"><a href="#5-4-3-手势识别" class="headerlink" title="5.4.3 手势识别"></a>5.4.3 手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断，随后系统将对应的 UIGestureRecognizer 标记为待处理，苹果注册了一个 Observer 监测 <strong>即将进入休眠</strong>，其回调函数会获取所有刚被标记为待处理的 UIGestureRecognizer，并执行UIGestureRecognizer 的回调，当有 UIGestureRecognizer 的状态变化时，这个回调都会进行相应处理。</p>
<h3 id="5-4-4-界面更新"><a href="#5-4-4-界面更新" class="headerlink" title="5.4.4 界面更新"></a>5.4.4 界面更新</h3><p>当在操作 UI 时，这个 UIView 或 CALayer 就被标记为待处理，并被提交到一个全局的容器去，苹果注册了一个 Observer 监测 <strong>即将进入休眠</strong> 和 <strong>即将退出</strong>，回调去执行一个很长的函数，这个函数里会遍历所有待处理的 UIView 或 CALayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="5-4-5-关于-GCD"><a href="#5-4-5-关于-GCD" class="headerlink" title="5.4.5 关于 GCD"></a>5.4.5 关于 GCD</h3><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block，也就是对应 handle_msg 处理消息：如果 dispatch 就执行 block 。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="5-4-6-PerformSelecter"><a href="#5-4-6-PerformSelecter" class="headerlink" title="5.4.6 PerformSelecter"></a>5.4.6 PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会 创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会 创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h1 id="6-RunLoop-Mode"><a href="#6-RunLoop-Mode" class="headerlink" title="6. RunLoop Mode"></a>6. RunLoop Mode</h1><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响。</p>
<h2 id="6-1-CFRunLoopMode"><a href="#6-1-CFRunLoopMode" class="headerlink" title="6.1 __CFRunLoopMode"></a>6.1 __CFRunLoopMode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;		</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;	<span class="comment">/* must have the run loop locked before locking this 锁mode前，先锁定RunLoop*/</span></span><br><span class="line">    CFStringRef _name;			 </span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="type">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    CFMutableSetRef _sources0;	<span class="comment">// 事件源set，就是version为0的__CFRunLoopSource</span></span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;	<span class="comment">// 观察者array</span></span><br><span class="line">    CFMutableArrayRef _timers;		<span class="comment">// 计时器array</span></span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;	<span class="comment">// port和source1对应</span></span><br><span class="line">    __CFPortSet _portSet;				<span class="comment">// 端口set</span></span><br><span class="line">    CFIndex _observerMask;			<span class="comment">// 这个字段是为了当前mode和匹配观察者状态。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	每添加一个观察者，就会</span></span><br><span class="line"><span class="comment">  	rlm-&gt;_observerMask |= rlo-&gt;_activities; （源代码）</span></span><br><span class="line"><span class="comment">  	这样就保证了这个字段有所有观察者当前的状态</span></span><br><span class="line"><span class="comment">  	然后在通知观察者时</span></span><br><span class="line"><span class="comment">  	rlm-&gt;_observerMask &amp; xxxx</span></span><br><span class="line"><span class="comment">  	就可以判断当前mode是否有对应状态的观察者，然后就会进行通知</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	下面两个宏，是这样定义的</span></span><br><span class="line"><span class="comment">  	#if DEPLOYMENT_TARGET_MACOSX		</span></span><br><span class="line"><span class="comment">		#define USE_DISPATCH_SOURCE_FOR_TIMERS 1</span></span><br><span class="line"><span class="comment">		#define USE_MK_TIMER_TOO 1</span></span><br><span class="line"><span class="comment">		#else			</span></span><br><span class="line"><span class="comment">		#define USE_DISPATCH_SOURCE_FOR_TIMERS 0</span></span><br><span class="line"><span class="comment">		#define USE_MK_TIMER_TOO 1</span></span><br><span class="line"><span class="comment">		#endif</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="type">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO	<span class="comment">// 那这里就是iOS要走的</span></span></span><br><span class="line">    <span class="type">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS		<span class="comment">// 是否是Windows环境</span></span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="type">void</span> (*_msgPump)(<span class="type">void</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="type">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-CFRunLoop"><a href="#6-2-CFRunLoop" class="headerlink" title="6.2 __CFRunLoop"></a>6.2 __CFRunLoop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;			<span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;				<span class="comment">// 唤醒loop的端口 【关键】</span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">		<span class="comment">/*线程和RunLoop是一一对应的，这个我们在附录解析吧*/</span></span><br><span class="line">  	<span class="type">pthread_t</span> _pthread;					<span class="comment">// 对应的线程</span></span><br><span class="line">    <span class="type">uint32_t</span> _winthread;				<span class="comment">// 对应的Windows的线程</span></span><br><span class="line">    CFMutableSetRef _commonModes;					<span class="comment">// 带有common属性的mode集合</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;			<span class="comment">// 带有common属性的source</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;				<span class="comment">// 当前运行的mode</span></span><br><span class="line">    CFMutableSetRef _modes;								<span class="comment">// mode的集合</span></span><br><span class="line">    </span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  			链表头指针，该链表保存了所有需要被 run loop 执行的 block。</span></span><br><span class="line"><span class="comment">      	外部通过调用 CFRunLoopPerformBlock 函数来向链表中添加一个 block 节点。</span></span><br><span class="line"><span class="comment">    		run loop 会在 CFRunLoopDoBlock 时遍历该链表，逐一执行 block。</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">  	<span class="comment">// 链表尾结点，用于插入block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    CFAbsoluteTime _runTime;			<span class="comment">// 运行时间</span></span><br><span class="line">    CFAbsoluteTime _sleepTime;		<span class="comment">// 睡眠时间</span></span><br><span class="line">    CFTypeRef _counterpart;			</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-RunLoop-入口"><a href="#7-RunLoop-入口" class="headerlink" title="7. RunLoop 入口"></a>7. RunLoop 入口</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> &#123;	<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">  <span class="comment">// 此时循环已经开始</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以在任何可用的运行循环模式创建另一个运行的循环运行激活</span></span><br><span class="line">SInt32 <span class="title function_">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">CF_ENUM</span><span class="params">(SInt32,  CFRunLoopRunResult)</span> &#123;</span><br><span class="line">    kCFRunLoopRunFinished = <span class="number">1</span>,</span><br><span class="line">    kCFRunLoopRunStopped = <span class="number">2</span>,</span><br><span class="line">    kCFRunLoopRunTimedOut = <span class="number">3</span>,</span><br><span class="line">    kCFRunLoopRunHandledSource = <span class="number">4</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-1-CFRunLoopRunSpecific"><a href="#7-1-CFRunLoopRunSpecific" class="headerlink" title="7.1 CFRunLoopRunSpecific"></a>7.1 CFRunLoopRunSpecific</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="title function_">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 进行mode检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">      <span class="comment">// 这个did不知道是干嘛的</span></span><br><span class="line">	Boolean did = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line">	<span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">  <span class="comment">// 真正运行的地方在这里， 这个方法巨长无比</span></span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">	rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-CFRunLoopRun"><a href="#7-2-CFRunLoopRun" class="headerlink" title="7.2 __CFRunLoopRun"></a>7.2 __CFRunLoopRun</h2><p>一段伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>精简部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   		这里有一段优化的代码 </span></span><br><span class="line"><span class="comment">   		检查loop是否停止</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  		 这里有一段关于GCD消息端口的设置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   		这里有一段设置超时时间的代码 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="type">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="type">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        HANDLE livePort = <span class="literal">NULL</span>;</span><br><span class="line">        Boolean windowsMessageReceived = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_LINUX</span></span><br><span class="line">        <span class="type">int</span> livePort = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line"><span class="comment">// 进行通知</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">// 执行添加的block</span></span><br><span class="line"><span class="comment">// 这个方法的内部，就是遍历_blocks_head这个链表</span></span><br><span class="line"><span class="comment">// 然后执行</span></span><br><span class="line"><span class="comment">// 其中的block是通过 CFRunLoopPerformBlock 添加的</span></span><br><span class="line"><span class="comment">// 这个方法就是 perfom 系列方法的底层</span></span><br><span class="line"><span class="comment">// 官方说 This method enqueues the block only and does not automatically wake up the specified run loop</span></span><br><span class="line"><span class="comment">// 因此有多次执行 __CFRunLoopDoBlocks</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">          <span class="comment">// 执行添加的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这里是否开始轮询，否则要休眠了</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0ULL</span> == timeout_context-&gt;termTSR);</span><br><span class="line"><span class="comment">// 这里是基于port的source1事件，采用goto语法</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAS_DISPATCH__</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_LINUX</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceFileDescriptors(CFPORTSET_NULL, dispatchPort, <span class="number">0</span>, &amp;livePort)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 即将休眠</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">    <span class="comment">// do not do any user callouts after this point (after notifying of sleeping)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAS_DISPATCH__</span></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? <span class="number">0.0</span> : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">      <span class="comment">// 调用 mach_msg 等待接受 mach_port 的消息</span></span><br><span class="line">      <span class="comment">// 等待被唤醒</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">                <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">                <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></span><br><span class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="type">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line"><span class="comment">// ………………代码省略</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_LINUX</span></span><br><span class="line"><span class="comment">// ………………代码省略</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced. Also, we don&#x27;t want them left</span></span><br><span class="line">        <span class="comment">// in there if this function returns.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAS_DISPATCH__</span></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">    <span class="comment">// CFRunLoopAfterWaiting</span></span><br><span class="line">    <span class="comment">// 循环唤醒之后的事件处理循环内，但在处理唤醒它的事件之前。 仅当运行循环在当前循环期间确实进入睡眠状态时才会发生此活动。</span></span><br><span class="line">    <span class="comment">// kCFRunLoopAfterWaiting</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"><span class="comment">// source1 事件源</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line"><span class="comment">// ………………代码省略</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">// 啥也不是</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">      <span class="comment">// 啥也不是</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="comment">// Always reset the wake up port, or risk spinning forever</span></span><br><span class="line">            ResetEvent(rl-&gt;_wakeUpPort);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">      <span class="comment">// 这里是dispatch的timer</span></span><br><span class="line">      <span class="comment">// 如：dispatch_after</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">      <span class="comment">// 基于mach的timer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAS_DISPATCH__</span></span><br><span class="line">      <span class="comment">// dispatch_main</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="type">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="type">void</span> *msg = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="type">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// source1 事件源唤醒</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">        sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">            (<span class="type">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">            CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS || DEPLOYMENT_TARGET_LINUX</span></span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="type">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 结束的判定</span></span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __HAS_DISPATCH__</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打完收工</span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-RunLoop-运用"><a href="#7-3-RunLoop-运用" class="headerlink" title="7.3 RunLoop 运用"></a>7.3 RunLoop 运用</h2><p>apple官方的运用，对比RunLoop结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</span><br><span class="line">             <span class="comment">// 系统事件</span></span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">           <span class="comment">// AutoreleasePool的通知</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">           <span class="comment">// 界面更新</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">           <span class="comment">// AutoreleasePool的通知</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.baidu.com">Coolnaut</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.baidu.com/2021/03/19/Runloop/">http://www.baidu.com/2021/03/19/Runloop/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.baidu.com" target="_blank">Coolnaut space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post_share"><div class="social-share" data-image="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E5%89%8D%E7%9E%BB/"><img class="prev-cover" src="https://s1.ax1x.com/2023/08/06/pPAsHW6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式笔记前瞻</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/29/autoreleasepool/"><img class="next-cover" src="https://i.niupic.com/images/2023/05/12/b6E8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">autoreleasepool</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/29/autoreleasepool/" title="autoreleasepool"><img class="cover" src="https://i.niupic.com/images/2023/05/12/b6E8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-30</div><div class="title">autoreleasepool</div></div></a></div><div><a href="/2022/09/01/iOS%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7%E5%85%A5%E9%97%A8%E7%AF%87/" title="iOS视频捕获入门"><img class="cover" src="https://i.niupic.com/images/2023/05/12/b6Ex.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">iOS视频捕获入门</div></div></a></div><div><a href="/2022/09/07/iOS%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7%E5%AE%9E%E8%B7%B5%E7%AF%87/" title="iOS视频捕获实践篇"><img class="cover" src="https://i.niupic.com/images/2023/05/12/b6Ex.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">iOS视频捕获实践篇</div></div></a></div><div><a href="/2022/09/15/iOS%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7%E8%BF%9B%E9%98%B6%E7%AF%87/" title="iOS视频捕获进阶篇"><img class="cover" src="https://i.niupic.com/images/2023/05/12/b6Ex.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-16</div><div class="title">iOS视频捕获进阶篇</div></div></a></div><div><a href="/2021/04/29/Swift%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/" title="Swift类的构造规则"><img class="cover" src="https://developer.apple.com/swift/images/swift-og.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-30</div><div class="title">Swift类的构造规则</div></div></a></div><div><a href="/2021/01/19/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8Swift/" title="一篇入门Swift"><img class="cover" src="https://i.niupic.com/images/2023/05/12/b6E6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-20</div><div class="title">一篇入门Swift</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Giscus</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODE1MC8zNDYxMw=="></div></div><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%95%E5%AD%90"><span class="toc-text">1. 引子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-RunLoop"><span class="toc-text">2. RunLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RunLoopSource"><span class="toc-text">3. RunLoopSource</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-CFRunLoopSource"><span class="toc-text">3.1 __CFRunLoopSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-CFRuntimeBase"><span class="toc-text">3.2 __CFRuntimeBase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-CFRunLoopSourceContext"><span class="toc-text">3.3 CFRunLoopSourceContext</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-CFRunLoopTimer"><span class="toc-text">4. __CFRunLoopTimer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-CFRunLoopTimerCallBack"><span class="toc-text">4.1 CFRunLoopTimerCallBack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-CFRunLoopTimerContext"><span class="toc-text">4.2 CFRunLoopTimerContext</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Runloop-Observer"><span class="toc-text">5. Runloop Observer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-CFRunLoopObserver"><span class="toc-text">5.1 __CFRunLoopObserver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-activities"><span class="toc-text">5.2 _activities</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-callout"><span class="toc-text">5.3 _callout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%BA%94%E7%94%A8"><span class="toc-text">5.4 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-AutoreleasePool"><span class="toc-text">5.4.1 AutoreleasePool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94"><span class="toc-text">5.4.2 事件响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB"><span class="toc-text">5.4.3 手势识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%96%B0"><span class="toc-text">5.4.4 界面更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-%E5%85%B3%E4%BA%8E-GCD"><span class="toc-text">5.4.5 关于 GCD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-6-PerformSelecter"><span class="toc-text">5.4.6 PerformSelecter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-RunLoop-Mode"><span class="toc-text">6. RunLoop Mode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-CFRunLoopMode"><span class="toc-text">6.1 __CFRunLoopMode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-CFRunLoop"><span class="toc-text">6.2 __CFRunLoop</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-RunLoop-%E5%85%A5%E5%8F%A3"><span class="toc-text">7. RunLoop 入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-CFRunLoopRunSpecific"><span class="toc-text">7.1 CFRunLoopRunSpecific</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-CFRunLoopRun"><span class="toc-text">7.2 __CFRunLoopRun</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-RunLoop-%E8%BF%90%E7%94%A8"><span class="toc-text">7.3 RunLoop 运用</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Coolnaut</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to coolanut space !</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'coolnaut/hexo_blog_comment',
    'data-repo-id': 'R_kgDOIt-nOA',
    'data-category-id': 'DIC_kwDOIt-nOM4CTZY1',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Livere' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>